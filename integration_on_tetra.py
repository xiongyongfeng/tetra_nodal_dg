import numpy as np
from scipy.integrate import nquad


# 定义被积函数
def integrand(r, s, t):
    # 避免除以零：当r接近0时返回一个大数或NaN，但nquad可能会处理
    # 但出于演示，我们直接计算
    # return (t + 1) * t / 2
    # return 0.5 * (r + s + t + 1) * (r + s + t + 2)
    # return (t + 1) * (s + 1)
    return -(r + s + t + 1) * (r + 1)


# 定义积分区域边界函数
# r的范围是从-1到某个上界，但需要满足 r+s+t <= -1 且 s,t >= -1
def bounds_t(r, s):
    # t的下限是-1，上限由不等式 t <= -1 - r - s 决定
    return [-1, -1 - r - s]


def bounds_s(r):
    # 对于给定的r，s的下限是-1，上限需要满足 s <= -1 - r - t 且 t>= -1。
    # 由于t的下限是-1，s的上限实际上可以由不等式和t的下限确定。
    # 从 r+s+t <= -1 且 t >= -1 可得 s <= -r - t, 但更直接的是先对t积分。
    # 这里采用：s的下限是-1，上限是 -1 - r ？ 注意，当t取最小值-1时，s <= -r - t = -r +1？ 需要仔细推导。
    # 实际上，从 r+s+t <= -1 和 t>=-1, s>=-1 可得：
    # s <= -1 - r - t, 由于t>=-1, 所以 s <= -1 - r - (-1) = -r.
    # 但s>= -1, 所以s的上限是 min(-r, ...)? 实际上区域是紧的。
    # 一个更严谨的方法是固定r后，s从-1到某个值，然后t从-1到-1-r-s。
    # 因此s的上限应该是-1 - r？ 因为当t取到最小值-1时，s <= -1 - r - (-1) = -r.
    # 但还需要确保上限不小于下限（-1）。
    # 例如，当r=0时，s的上限是0，但s>= -1, 所以s在[-1, 0]。
    # 当r=0.5时，s的上限是-0.5。
    # 但r可能是正的，也可能是负的。
    # 实际上，为了保证区域非空，需要 -1 - r - (-1) >= -1, 即 -r >= -1, 即 r<=1.
    # 综合考虑，s的上限为 -1 - r 可能不对，因为当r>0时，-1-r < -1。
    # 正确推导：对于固定的r，s必须满足 s >= -1 且 存在t使得 t>=-1 且 t <= -1 - r - s.
    # 这意味着 -1 <= -1 - r - s, 即 s <= -r.
    # 所以s的范围是[-1, -r]，但前提是-r >= -1，即r<=1。
    # 同时r>= -1。
    # 因此，s的下限是-1，上限是 -r（因为-r可能大于或小于-1，但需要夹紧）?
    # 实际上，由于r>= -1, -r <= 1, 而s的下限是-1，所以上限应该是min(1, -r)？但不对。
    # 例如r=-0.5, -r=0.5, s在[-1, 0.5]。
    # 例如r=0.5, -r=-0.5, 但s>= -1, 所以s在[-1, -0.5]。
    # 所以s的上限是 -r。
    return [-1, -r]


def bounds_r():
    # r的范围是从-1到？ 需要确保区域非空。
    # 从不等式 r+s+t <= -1 和 s,t >= -1 可得 r <= 1。
    # 例如，当s和t都取-1时，r <= 1。
    # 同时r>= -1。
    return [-1, 1]


# 调用nquad进行积分
# 注意：被积函数在r=0有奇点，积分可能会发散或得到无意义结果
result, error_estimate = nquad(integrand, [bounds_t, bounds_s, bounds_r])

print(f"数值积分结果: {result}")
print(f"误差估计: {error_estimate}")

# 由于预计积分发散，结果可能是inf或nan，或者是一个很大的数。
